const OAuth=require("oauth"),Inventory=require("../models/inventory"),Order=require("../models/order"),{isObjectsSame:isObjectsSame,mappingOrderItemsForChecked:mappingOrderItemsForChecked}=require("./functions"),{logger:logger}=require("./logger"),{update:update}=require("../models/inventory"),{increaseApiCallAmount:increaseApiCallAmount,hasUserExceededAPiAmount:hasUserExceededAPiAmount}=require("../helpers/ApiHelper"),_=require("lodash");module.exports.inventorySingle=(async(e,r)=>{await Inventory.findOne({CONSUMER_KEY:e.CONSUMER_KEY,inventory_id:r},async(i,o)=>{if(i)return logger.error(`Could not find inventory for user ${e.email} : ${i}`),!1;{const i=new OAuth.OAuth(e.TOKEN_VALUE,e.TOKEN_SECRET,e.CONSUMER_KEY,e.CONSUMER_SECRET,"1.0",null,"HMAC-SHA1");if(await hasUserExceededAPiAmount(e._id))return void logger.error("User has exceeded the API limit of bricklink'");await increaseApiCallAmount(e._id),await i.get("https://api.bricklink.com/api/store/v1/inventories/"+r,i._requestUrl,i._accessUrl,async(i,o)=>{if(i){if(logger.error(`receiving order items for user ${e.email} gave error : ${i}`),i.code="ETIMEDOUT")return logger.warn(JSON.stringify(o)),logger.warn(`Timeout received by bricklink API from user ${e.email}`),!1;if(i.code="ECONNRESET")return void logger.warn("Connection reset, please check your internet connection")}if(!o||!o.meta||200!=o.meta)return logger.error(`Could not update single inventory ${r} for user ${e.email}: ${i}`),!1;{let i={CONSUMER_KEY:e.CONSUMER_KEY,...o};await Inventory({CONSUMER_KEY:e.CONSUMER_KEY,inventory_id:r},i)}})}})}),module.exports.inventoryAll=(async e=>{const r=new OAuth.OAuth(e.TOKEN_VALUE,e.TOKEN_SECRET,e.CONSUMER_KEY,e.CONSUMER_SECRET,"1.0",null,"HMAC-SHA1");await hasUserExceededAPiAmount(e._id)?logger.error("User has exceeded the API limit of bricklink'"):(await increaseApiCallAmount(e._id),await r.get("https://api.bricklink.com/api/store/v1/inventories",r._requestUrl,r._accessUrl,async(r,i)=>{if(itemsProcessedFailed=!1,r){if(logger.error(`receiving order items for user ${e.email} gave error : ${r}`),r.code="ETIMEDOUT")return logger.warn(JSON.stringify(i)),itemsProcessedFailed=!0,logger.warn(`Timeout received by bricklink API from user ${e.email}`),!1;if(r.code="ECONNRESET")return logger.warn(i),itemsProcessedFailed=!0,void logger.warn("Connection reset, please check your internet connection")}try{i=JSON.parse(i)}catch(r){return logger.error(`could not parse data for inventory for user ${e.email}: ${r}`),!1}if(i&&i.meta&&200==i.meta.code){logger.info(`preparing to save ${i.data.length} items to inventory in our database for user ${e.email}`);i.data.length;let r=0,o=0;itemsProcessed=[],i.data.forEach(async i=>{if(itemsProcessed.push(i.inventory_id),await Inventory.findOne({CONSUMER_KEY:e.CONSUMER_KEY,inventory_id:i.inventory_id}))r++,await Inventory.updateOne({CONSUMER_KEY:e.CONSUMER_KEY,inventory_id:i.inventory_id},{CONSUMER_KEY:e.CONSUMER_KEY,...i},(r,o)=>{if(r)return logger.error(`Could not save new inventory item ${i.inventory_id} of user ${e.email}: ${r}`),!1});else{o++;const r=new Inventory({CONSUMER_KEY:e.CONSUMER_KEY,...i});await r.save((r,o)=>{if(r)return logger.error(`Could not save new inventory item ${i.inventory_id} of user ${e.email}: ${r}`),!1;logger.info(`Successfully saved new inventory item ${i.inventory_id} for user ${e.email}`)})}}),itemsProcessedFailed&&logger.warn("itemsProcessedFailed !!"),itemsProcessedFailed||(allItems=await Inventory.find({CONSUMER_KEY:e.CONSUMER_KEY}),allItems.forEach(async r=>{-1===itemsProcessed.indexOf(r.inventory_id)&&await Inventory.deleteOne({inventory_id:r.inventory_id,CONSUMER_KEY:e.CONSUMER_KEY})}))}else logger.warn(`Could not receive any data to update inventory for user ${e.email}: ${i.meta.description}`),logger.debug(`${i.meta.description}`)}))}),module.exports.ordersAll=(async(e,r="")=>{const i=new OAuth.OAuth(e.TOKEN_VALUE,e.TOKEN_SECRET,e.CONSUMER_KEY,e.CONSUMER_SECRET,"1.0",null,"HMAC-SHA1");await hasUserExceededAPiAmount(e._id)?logger.error("User has exceeded the API limit of bricklink'"):(await increaseApiCallAmount(e._id),await i.get("https://api.bricklink.com/api/store/v1/orders"+r,i._requestUrl,i._accessUrl,async(r,o)=>{if(r)return logger.error(`receiving order items for user ${e.email} gave error : ${r}`),(r.code="ETIMEDOUT")?(logger.warn(JSON.stringify(o)),logger.warn(`Timeout received by bricklink API from user ${e.email}`),!1):(r.code="ECONNRESET")?(logger.warn(o),void logger.warn("Connection reset, please check your internet connection")):void logger.warn(`Error ${r.code}: retrying later...`);try{o=JSON.parse(o)}catch(r){return logger.error(`could not parse data for orders for user ${e.email}: ${r}`),!1}if(o&&o.meta&&200==o.meta.code){if(logger.info(`Found ${o.data.length} orders for user ${e.email}`),await hasUserExceededAPiAmount(e._id,o.data.length))return void logger.error("User has exceeded the API limit of bricklink'");console.log(o.data.length),await increaseApiCallAmount(e._id,o.data.length),o.data.forEach(async r=>{let o=await Order.findOne({consumer_key:e.CONSUMER_KEY,order_id:r.order_id});await i.get("https://api.bricklink.com/api/store/v1/orders/"+r.order_id+"/items",i._requestUrl,i._accessUrl,async(i,t)=>{if(i){if(logger.error(`receiving order items for user ${e.email} gave error : ${i}`),i.code="ETIMEDOUT")return logger.warn(JSON.stringify(t)),logger.warn(`Timeout received by bricklink API from user ${e.email}`),!1;if(i.code="ECONNRESET")return void logger.warn("Connection reset, please check your internet connection")}try{t=JSON.parse(t)}catch(e){logger.warn(`Parsing order items failed, err: ${e}`)}if(t&&t.meta&&200==t.meta.code){if("PURGED"===r.status.toUpperCase())return;if(o){let i=r,n=_.pick(o,_.keysIn(i));n.order_id=Number(n.order_id),i.date_ordered=new Date(String(i.date_ordered)),i.date_status_changed=new Date(String(i.date_status_changed)),i.payment.date_paid&&(i.payment.date_paid=new Date(String(i.payment.date_paid))),n=_(n).toPairs().sortBy(0).fromPairs().value(),i=_(i).toPairs().sortBy(0).fromPairs().value();const a=JSON.stringify(n,null,0)===JSON.stringify(i,null,0);let s=o.items,d=_.pick(t.data,_.keysIn(s));d=_(d).toPairs().sortBy(0).fromPairs().value();const l=JSON.stringify(n,null,0)===JSON.stringify(i,null,0);if(a||l)return;logger.info(`new update for order ${r.order_id}`);let c=0;const u=mappingOrderItemsForChecked(o.items);t.data.forEach(e=>{e.forEach(e=>{e.isChecked=u.get(e.inventory_id),e.isChecked&&c++})});const g={orders_checked:c,description:o.description,consumer_key:e.CONSUMER_KEY,...r,items:t.data};Order.updateOne({consumer_key:e.CONSUMER_KEY,order_id:r.order_id},g,(i,o)=>{i&&logger.error(`Could not update order ${r.order_id} of user ${e.email} : ${i}`)})}else{logger.info(`Order of id ${r.order_id} not found in our database for user ${e.email}`),t.data.forEach(e=>{e.forEach(e=>{e.isChecked=!1})});const i=new Order({orders_checked:0,description:"",consumer_key:e.CONSUMER_KEY,...r,items:t.data});await i.save((i,o)=>{if(i)return logger.error(`Could not save new order ${r.order_id} of user ${e.email} ${i}`),!1})}}else logger.warn(`Could not receive any data to update orders items for user ${e.email}`)})}),logger.info(`successfully found all orders for user ${e.email}`)}else logger.warn(`Could not receive any data to update orders for user ${e.email} : ${o.meta.description}`)}))});